from fractions import Fraction #Подключается модуль `fractions`, который предоставляет класс `Fraction` для работы с обыкновенными дробями.

class Polynomial: #Определение класса Polynomial для работы с многочленами
    # ИНИЦИАЛИЗАЦИЯ класса многочлена с коэффициентами
    def __init__(self, coefficients): # init - вызов при создании объекта класса, self _ ссылка на текущий экземпляр объекта, coefficients - список коэфф
        self.coefficients = [Fraction(c) for c in coefficients] # создание списка, который итерируется по каждому элементу списка coefficients, Fraction(c) - представляет в виде дробей

    # СЛОЖЕНИЕ многочленов
    def __add__(self, other):
        max_len = max(len(self.coefficients), len(other.coefficients)) # вычисляется max длина двух списков коэфф
        c1 = self.coefficients + [0] * (max_len - len(self.coefficients)) # если длины оказались разными, то дополняет их нулями (где недостаёт)
        c2 = other.coefficients + [0] * (max_len - len(other.coefficients)) # для корректности вычислений
        result = [c1[i] + c2[i] for i in range(max_len)] # поэлементное сложение соответствующих коэффициентов двух многочленов.
        return Polynomial(result)

    # Вычисление значения многочлена в точке
    def evaluate(self, x): #Определение метода evaluate, который принимает на вход self (объект) и x (точка, где нужно вычислить многочлен).
        result = 0
        x = Fraction(x)  # Приведение x к типу Fraction (работа с дробями)
        for i in range(len(self.coefficients)): #Цикл по индексам коэффициентов многочлена: i указывает на степень текущей переменной x.
            result += self.coefficients[i] * (x ** i) #В текущий результат добавляется значение члена многочлена: коэффициент self.coefficients[i] умножается на x в степени i.
        return result

    # Взятие производной многочлена
    def derivative(self): # метод для объекта класса polynomial
        derived_coeffs = [] # Создаётся пустой список для хранения коэффициентов производной
        for i in range(1, len(self.coefficients)): # запускается цикл, перебирающий индексы коэффициентов (начиная с 1, так как свободный член пропускается)
            derived_coeffs.append(i * self.coefficients[i]) #Каждый коэффициент умножается на соответствующую степень \( i \), и результат добавляется в список derived_coeffs
        return Polynomial(derived_coeffs)

    # Запись многочлена в файл
    def save_to_file(self, file_name): #Определяется метод save_to_file, который принимает имя файла file_name в качестве аргумента
        try: #Начало блока try для перехвата возможных ошибок при записи в файл
            with open(file_name, 'w') as file:
                file.write(str(self)) #В файл записывается строковое представление объекта (вызван метод str(self))
            print(f"Многочлен успешно записан в файл: {file_name}")
        except Exception as e: #Ловится исключение Exception, если в процессе записи возникли какие-либо ошибки
            print(f"Ошибка при записи в файл: {e}")

    # Найти целые корни
    def find_integer_roots(self):
        if not all(c.denominator == 1 for c in self.coefficients): #Проверяется, что все коэффициенты являются целыми числами (их знаменатель равен 1)
            raise ValueError("Все коэффициенты должны быть целыми.")

        a0 = int(self.coefficients[0])  # Свободный член
        an = int(self.coefficients[-1])  # Коэффициент старшей степени
        possible_roots = [] #Создается пустой список possible_roots для хранения потенциальных целых корней

        for p in range(1, abs(a0) + 1): #  Итерация по всем числам от 1 до модуля свободного члена (a0), чтобы найти его делители
            if a0 % p == 0:  #  Проверяется, является ли текущее число p делителем свободного члена a0
                for q in range(1, abs(an) + 1): #Итерация по всем числам от 1 до модуля коэффициента старшей степени (an), чтобы найти его делители
                    if an % q == 0:  # Проверяется, является ли текущее число q делителем коэффициента старшей степени an
                        possible_roots.extend([p // q, -p // q]) #Добавляются в список possible_roots положительные и отрицательные дроби вида p / q (внешний делитель делится на делитель старшего члена)

        # Оставляем только те значения, которые действительно являются корнями
        integer_roots = [] #Создаётся пустой список integer_roots, куда будут добавляться значения, которые являются корнями уравнения
        for r in set(possible_roots): #Выполняется цикл по уникальным значениям из множества (set()) возможных корней, чтобы избежать проверки повторяющихся корней
            if self.evaluate(r) == 0: #Проверяется, является ли текущий r корнем уравнения. Метод evaluate(r) вычисляет значение функции в точке r, соответственно, если результат равен 0, это означает, что r — корень
                integer_roots.append(r) #  Если проверка прошла успешно, корень r добавляется в список integer_roots
        return sorted(integer_roots)

        # Представление многочлена в виде строки
    def __str__(self):
        terms = [] #Создаётся пустой список terms, который будет содержать строки, представляющие члены многочлена
        for i in range(len(self.coefficients)): #Запускается цикл по индексам списка self.coefficients, где находятся коэффициенты многочлена
            coef = self.coefficients[i] # Извлекается коэффициент текущего члена многочлена
            if coef == 0:
                continue #Если коэффициент равен 0, пропускаем текущую итерацию, так как нулевые члены в многочлене не отображаются
            term = f"{coef}" # Преобразуем коэффициент в строку и добавляем в переменную term
            if i == 1: # Проверяем, является ли текущий член линейным (при x без степени)
                term += "x" #  Если текущий член линейный, добавляем "x" к строке term
            elif i > 1:
                term += f"x^{i}" #   Добавляем к строке x и его степень i, формируя строку для члена многочлена.
            terms.append(term) # Готовый член многочлена добавляется в список terms
        return " + ".join(terms).replace("+ -", "- ") #Формируем строку из всех членов многочлена, объединяя их через " + ". Затем заменяем " + -" на "- " для правильного представления знаков. Возвращается итоговая строка


# Пример использования
if __name__ == "__main__": #  Проверяет, запущен ли скрипт напрямую, а не импортирован как модуль
    p1 = Polynomial([1, -3, 2])  # x^2 - 3x + 2
    p2 = Polynomial([1, -1])     # x - 1

    # Сложение многочленов
    p_sum = p1 + p2
    print("Сумма:", p_sum)

    # Сохранение многочлена в файл
    filename = "polynomial_output.txt"
    p_sum.save_to_file(filename) # Вызывается метод save_to_file для объекта p_sum, который сохраняет многочлен в файл с именем polynomial_output.txt

    # Вычисление значения в точке
    print("Значение в x=2:", p1.evaluate(2))  # вычисление значение многочлена в точке x = 2

    # Производная
    p_derivative = p1.derivative() #   Вызывается метод derivative() для объекта p1, который должен вернуть производную многочлена
    print("Производная:", p_derivative)

